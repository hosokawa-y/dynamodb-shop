## DynamoDBトランザクションとは

複数のアイテムに対する操作を**原子的（All or Nothing）**に実行。

### 特徴

| 項目 | 内容 |
|------|------|
| 最大アイテム数 | 100アイテム/トランザクション |
| 最大サイズ | 4MB/トランザクション |
| 分離レベル | Serializable |
| 対象 | 同一リージョン内のテーブル（複数テーブル可） |

---

## API

| API | 用途 |
|-----|------|
| TransactWriteItems | 複数アイテムの書き込み/更新/削除 |
| TransactGetItems | 複数アイテムの一貫性のある読み取り |

---

## TransactWriteItems

### 操作タイプ

| 操作 | 説明 |
|------|------|
| Put | アイテム作成/上書き |
| Update | アイテム更新 |
| Delete | アイテム削除 |
| ConditionCheck | 条件チェックのみ（書き込みなし） |

### 基本構文（Go）

```go
_, err := client.TransactWriteItems(ctx, &dynamodb.TransactWriteItemsInput{
    TransactItems: []types.TransactWriteItem{
        {
            Put: &types.Put{
                TableName: aws.String("DynamoDBShop"),
                Item:      orderItem,
            },
        },
        {
            Update: &types.Update{
                TableName:        aws.String("DynamoDBShop"),
                Key:              productKey,
                UpdateExpression: aws.String("SET Stock = Stock - :qty"),
                ConditionExpression: aws.String("Stock >= :qty"),
                ExpressionAttributeValues: map[string]types.AttributeValue{
                    ":qty": &types.AttributeValueMemberN{Value: "2"},
                },
            },
        },
        {
            Delete: &types.Delete{
                TableName: aws.String("DynamoDBShop"),
                Key:       cartItemKey,
            },
        },
    },
})
```

---

## 注文確定トランザクション（実装例）

Eコマースの注文確定処理:
1. 注文レコード作成
2. 各商品の在庫減算（条件付き）
3. カートアイテム削除

```go
func (s *OrderService) PlaceOrder(ctx context.Context, userID string) (*Order, error) {
    // 1. カート取得
    cartItems, err := s.cartRepo.GetByUserID(ctx, userID)
    if err != nil {
        return nil, err
    }
    if len(cartItems) == 0 {
        return nil, ErrEmptyCart
    }

    orderID := uuid.New().String()
    now := time.Now()
    var totalAmount int

    // トランザクションアイテム構築
    transactItems := []types.TransactWriteItem{}

    // 2. 注文ヘッダー作成
    for _, item := range cartItems {
        totalAmount += item.Price * item.Quantity
    }

    orderItem, _ := attributevalue.MarshalMap(map[string]interface{}{
        "PK":          "USER#" + userID,
        "SK":          "ORDER#" + orderID,
        "EntityType":  "ORDER",
        "OrderId":     orderID,
        "Status":      "CONFIRMED",
        "TotalAmount": totalAmount,
        "OrderDate":   now.Format(time.RFC3339),
    })
    transactItems = append(transactItems, types.TransactWriteItem{
        Put: &types.Put{
            TableName: aws.String(s.tableName),
            Item:      orderItem,
        },
    })

    // 3. 各商品の処理
    for _, item := range cartItems {
        // 在庫減算（条件付き）
        transactItems = append(transactItems, types.TransactWriteItem{
            Update: &types.Update{
                TableName: aws.String(s.tableName),
                Key: map[string]types.AttributeValue{
                    "PK": &types.AttributeValueMemberS{Value: "PRODUCT#" + item.ProductID},
                    "SK": &types.AttributeValueMemberS{Value: "METADATA"},
                },
                UpdateExpression:    aws.String("SET Stock = Stock - :qty"),
                ConditionExpression: aws.String("Stock >= :qty"),
                ExpressionAttributeValues: map[string]types.AttributeValue{
                    ":qty": &types.AttributeValueMemberN{Value: fmt.Sprintf("%d", item.Quantity)},
                },
            },
        })

        // 注文明細作成
        orderDetailItem, _ := attributevalue.MarshalMap(map[string]interface{}{
            "PK":        "ORDER#" + orderID,
            "SK":        "ITEM#" + item.ProductID,
            "ProductId": item.ProductID,
            "Name":      item.ProductName,
            "Price":     item.Price,
            "Quantity":  item.Quantity,
        })
        transactItems = append(transactItems, types.TransactWriteItem{
            Put: &types.Put{
                TableName: aws.String(s.tableName),
                Item:      orderDetailItem,
            },
        })

        // カートから削除
        transactItems = append(transactItems, types.TransactWriteItem{
            Delete: &types.Delete{
                TableName: aws.String(s.tableName),
                Key: map[string]types.AttributeValue{
                    "PK": &types.AttributeValueMemberS{Value: "USER#" + userID},
                    "SK": &types.AttributeValueMemberS{Value: "CART#" + item.ProductID},
                },
            },
        })
    }

    // 4. トランザクション実行
    _, err = s.client.TransactWriteItems(ctx, &dynamodb.TransactWriteItemsInput{
        TransactItems: transactItems,
    })

    if err != nil {
        return nil, s.handleTransactionError(err)
    }

    return &Order{
        ID:          orderID,
        UserID:      userID,
        Status:      "CONFIRMED",
        TotalAmount: totalAmount,
        OrderDate:   now,
    }, nil
}
```

---

## エラーハンドリング

### TransactionCanceledException

トランザクションの一部が失敗した場合に発生。

```go
func (s *OrderService) handleTransactionError(err error) error {
    var cancelErr *types.TransactionCanceledException
    if !errors.As(err, &cancelErr) {
        return err
    }

    // どの操作が失敗したか確認
    for i, reason := range cancelErr.CancellationReasons {
        if reason.Code == nil {
            continue
        }

        switch *reason.Code {
        case "ConditionalCheckFailed":
            // 条件チェック失敗（在庫不足など）
            return fmt.Errorf("操作 %d: 在庫不足", i)
        case "ItemCollectionSizeLimitExceeded":
            return fmt.Errorf("操作 %d: サイズ制限超過", i)
        case "TransactionConflict":
            return fmt.Errorf("操作 %d: 競合発生", i)
        }
    }

    return err
}
```

### 主なエラーコード

| コード | 原因 |
|--------|------|
| ConditionalCheckFailed | ConditionExpressionが満たされなかった |
| ItemCollectionSizeLimitExceeded | LSI使用時のサイズ制限超過 |
| TransactionConflict | 同じアイテムに対する同時トランザクション |
| ProvisionedThroughputExceeded | キャパシティ不足 |
| ValidationError | リクエストの検証エラー |

---

## ConditionCheck（条件チェックのみ）

書き込みはせず、条件が満たされているか確認するだけ。

```go
// ユーザーが存在することを確認（書き込みなし）
transactItems = append(transactItems, types.TransactWriteItem{
    ConditionCheck: &types.ConditionCheck{
        TableName: aws.String(s.tableName),
        Key: map[string]types.AttributeValue{
            "PK": &types.AttributeValueMemberS{Value: "USER#" + userID},
            "SK": &types.AttributeValueMemberS{Value: "PROFILE"},
        },
        ConditionExpression: aws.String("attribute_exists(PK)"),
    },
})
```

---

## TransactGetItems

複数アイテムを一貫性を持って読み取り。

```go
result, err := client.TransactGetItems(ctx, &dynamodb.TransactGetItemsInput{
    TransactItems: []types.TransactGetItem{
        {
            Get: &types.Get{
                TableName: aws.String("DynamoDBShop"),
                Key: map[string]types.AttributeValue{
                    "PK": &types.AttributeValueMemberS{Value: "PRODUCT#p001"},
                    "SK": &types.AttributeValueMemberS{Value: "METADATA"},
                },
            },
        },
        {
            Get: &types.Get{
                TableName: aws.String("DynamoDBShop"),
                Key: map[string]types.AttributeValue{
                    "PK": &types.AttributeValueMemberS{Value: "PRODUCT#p002"},
                    "SK": &types.AttributeValueMemberS{Value: "METADATA"},
                },
            },
        },
    },
})
```

---

## 制限事項

| 制限 | 値 |
|------|-----|
| 最大アイテム数 | 100 |
| 最大リクエストサイズ | 4MB |
| 同一アイテムへの操作 | 1トランザクション内で1回のみ |
| GSI | トランザクションで直接操作不可 |
| 冪等性トークン | ClientRequestToken で24時間有効 |

---

## RDBトランザクションとの比較

| 項目 | RDB | DynamoDB |
|------|-----|----------|
| ACID | 完全サポート | 限定的（100アイテムまで） |
| 分離レベル | 選択可能 | Serializable固定 |
| ロールバック | 自動 | 自動 |
| 複数テーブル | 可能 | 可能（同一リージョン） |
| ネストトランザクション | 可能（DB依存） | 不可 |

---

## 学習メモ

```
ここに学習中のメモを追記
```
