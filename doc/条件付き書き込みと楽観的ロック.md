## 条件付き書き込みとは

**ConditionExpression**: 指定した条件が満たされた場合のみ書き込みを実行。

### ユースケース

- 上書き防止（既存アイテムがない場合のみ作成）
- 在庫チェック（在庫が十分な場合のみ減算）
- 楽観的ロック（Versionが一致する場合のみ更新）

---

## 基本構文

```go
_, err := client.PutItem(ctx, &dynamodb.PutItemInput{
    TableName: aws.String("DynamoDBShop"),
    Item:      item,
    ConditionExpression: aws.String("条件式"),
    ExpressionAttributeValues: map[string]types.AttributeValue{
        ":value": &types.AttributeValueMemberS{Value: "xxx"},
    },
})
```

### 条件が満たされない場合

`ConditionalCheckFailedException` エラーが発生。

```go
var ccf *types.ConditionalCheckFailedException
if errors.As(err, &ccf) {
    // 条件が満たされなかった
    log.Println("条件チェック失敗")
}
```

---

## 条件式の例

### 存在チェック

```go
// アイテムが存在しない場合のみ作成
ConditionExpression: "attribute_not_exists(PK)"

// アイテムが存在する場合のみ更新
ConditionExpression: "attribute_exists(PK)"
```

### 値の比較

```go
// 在庫が十分な場合のみ減算
ConditionExpression: "Stock >= :qty"
ExpressionAttributeValues: {":qty": 5}

// ステータスが特定の値の場合のみ更新
ConditionExpression: "Status = :expected"
ExpressionAttributeValues: {":expected": "PENDING"}
```

### 複合条件

```go
// AND条件
ConditionExpression: "attribute_exists(PK) AND Stock >= :qty"

// OR条件
ConditionExpression: "Status = :s1 OR Status = :s2"
```

---

## 楽観的ロック

複数のクライアントが同時に更新しようとした場合の競合を防ぐ。

### 仕組み

1. アイテムに `Version` 属性を持つ
2. 更新時に「現在のVersionが期待値と一致する場合のみ更新」
3. 成功したらVersionを+1
4. 失敗したら再読み込みしてリトライ

```
Client A: Version=1 を読み取り
Client B: Version=1 を読み取り
Client A: Version=1 を確認して更新 → 成功、Version=2 に
Client B: Version=1 を確認して更新 → 失敗（既にVersion=2）
Client B: 再読み込み、Version=2 で再試行
```

---

## 楽観的ロック実装（Go）

### アイテム構造

```go
type Product struct {
    PK       string
    SK       string
    Name     string
    Price    int
    Stock    int
    Version  int  // 楽観的ロック用
}
```

### 更新処理

```go
func (r *ProductRepository) Update(ctx context.Context, product *Product) error {
    _, err := r.client.UpdateItem(ctx, &dynamodb.UpdateItemInput{
        TableName: aws.String("DynamoDBShop"),
        Key: map[string]types.AttributeValue{
            "PK": &types.AttributeValueMemberS{Value: product.PK},
            "SK": &types.AttributeValueMemberS{Value: product.SK},
        },
        UpdateExpression: aws.String(
            "SET #name = :name, Price = :price, Version = :newVersion",
        ),
        ConditionExpression: aws.String("Version = :currentVersion"),
        ExpressionAttributeNames: map[string]string{
            "#name": "Name", // Nameは予約語なのでプレースホルダー使用
        },
        ExpressionAttributeValues: map[string]types.AttributeValue{
            ":name":           &types.AttributeValueMemberS{Value: product.Name},
            ":price":          &types.AttributeValueMemberN{Value: fmt.Sprintf("%d", product.Price)},
            ":currentVersion": &types.AttributeValueMemberN{Value: fmt.Sprintf("%d", product.Version)},
            ":newVersion":     &types.AttributeValueMemberN{Value: fmt.Sprintf("%d", product.Version+1)},
        },
    })

    var ccf *types.ConditionalCheckFailedException
    if errors.As(err, &ccf) {
        return ErrOptimisticLockFailed
    }
    return err
}
```

### リトライロジック

```go
func (s *ProductService) UpdateWithRetry(ctx context.Context, productID string, updateFn func(*Product)) error {
    maxRetries := 3

    for i := 0; i < maxRetries; i++ {
        // 1. 最新データを読み取り
        product, err := s.repo.GetByID(ctx, productID)
        if err != nil {
            return err
        }

        // 2. 更新内容を適用
        updateFn(product)

        // 3. 楽観的ロック付きで更新
        err = s.repo.Update(ctx, product)
        if err == nil {
            return nil // 成功
        }

        if errors.Is(err, ErrOptimisticLockFailed) {
            // 競合発生、リトライ
            log.Printf("楽観的ロック失敗、リトライ %d/%d", i+1, maxRetries)
            continue
        }

        return err // その他のエラー
    }

    return ErrMaxRetriesExceeded
}
```

---

## 在庫チェック付き購入処理

```go
func (s *CartService) AddToCart(ctx context.Context, userID, productID string, qty int) error {
    // 在庫を減らさずにチェックのみ
    product, err := s.productRepo.GetByID(ctx, productID)
    if err != nil {
        return err
    }

    if product.Stock < qty {
        return ErrInsufficientStock
    }

    // カートに追加（在庫は注文確定時に減らす）
    return s.cartRepo.AddItem(ctx, userID, productID, qty)
}
```

> **注意**: 実際の在庫減算は注文確定時にトランザクションで行う。カート追加時点では在庫は減らさない。

---

## RDBとの比較

| 項目 | RDB (悲観的ロック) | DynamoDB (楽観的ロック) |
|------|-------------------|------------------------|
| 方式 | SELECT FOR UPDATE | ConditionExpression |
| ロック期間 | トランザクション中 | なし（書き込み時のみ） |
| 競合時 | 待機 | 即座に失敗 |
| スループット | 低（ロック待ち） | 高（ロックなし） |
| 向いている | 競合が多い場合 | 競合が少ない場合 |

---

## 学習メモ

```
ここに学習中のメモを追記
```
