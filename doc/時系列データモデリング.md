## 時系列データとは

時間に紐づくデータ。例：
- センサーデータ
- ログデータ
- 価格履歴
- アクセス履歴

---

## DynamoDBでの時系列データ設計

### 基本パターン

```
PK: エンティティID
SK: タイムスタンプ（またはプレフィックス+タイムスタンプ）
```

### 今回のプロジェクトでの設計

| データ | PK | SK |
|--------|----|----|
| 価格履歴 | `PRODUCT#<productId>` | `PRICE#<timestamp>` |
| 在庫ログ | `PRODUCT#<productId>` | `INVLOG#<timestamp>` |
| 行動ログ | `USER#<userId>` | `ACTIVITY#<timestamp>` |

---

## タイムスタンプ形式

### ISO 8601形式（推奨）

```
2024-01-15T10:30:00Z
2024-01-15T10:30:00.123Z  # ミリ秒付き
```

**メリット**:
- 文字列としてソート可能
- 人間が読みやすい
- タイムゾーン明示

### Unix Epoch

```
1705315800        # 秒
1705315800123     # ミリ秒
```

**メリット**:
- 数値演算が容易
- ストレージ効率

---

## 範囲クエリ

### 基本構文

```go
result, err := client.Query(ctx, &dynamodb.QueryInput{
    TableName:              aws.String("DynamoDBShop"),
    KeyConditionExpression: aws.String("PK = :pk AND SK BETWEEN :start AND :end"),
    ExpressionAttributeValues: map[string]types.AttributeValue{
        ":pk":    &types.AttributeValueMemberS{Value: "PRODUCT#p001"},
        ":start": &types.AttributeValueMemberS{Value: "PRICE#2024-01-01T00:00:00Z"},
        ":end":   &types.AttributeValueMemberS{Value: "PRICE#2024-01-31T23:59:59Z"},
    },
})
```

### SK条件演算子

| 演算子 | 用途 | 例 |
|--------|------|-----|
| `=` | 完全一致 | 特定時刻のデータ |
| `begins_with` | 前方一致 | 特定日のデータ（`2024-01-15`） |
| `BETWEEN` | 範囲 | 期間指定 |
| `<`, `<=`, `>`, `>=` | 比較 | 特定時刻より前/後 |

---

## 価格履歴の実装例

### データ構造

```go
type PriceHistory struct {
    PK        string    // PRODUCT#<productId>
    SK        string    // PRICE#<timestamp>
    ProductID string
    Price     int
    ChangedBy string    // 変更者
    Reason    string    // 変更理由
    CreatedAt time.Time
}
```

### 価格更新時に履歴記録

```go
func (s *ProductService) UpdatePrice(ctx context.Context, productID string, newPrice int, changedBy string) error {
    now := time.Now()

    // トランザクションで商品更新と履歴作成を同時実行
    transactItems := []types.TransactWriteItem{
        // 1. 商品の価格を更新
        {
            Update: &types.Update{
                TableName: aws.String(s.tableName),
                Key: map[string]types.AttributeValue{
                    "PK": &types.AttributeValueMemberS{Value: "PRODUCT#" + productID},
                    "SK": &types.AttributeValueMemberS{Value: "METADATA"},
                },
                UpdateExpression: aws.String("SET Price = :price, UpdatedAt = :now"),
                ExpressionAttributeValues: map[string]types.AttributeValue{
                    ":price": &types.AttributeValueMemberN{Value: fmt.Sprintf("%d", newPrice)},
                    ":now":   &types.AttributeValueMemberS{Value: now.Format(time.RFC3339)},
                },
            },
        },
        // 2. 価格履歴を記録
        {
            Put: &types.Put{
                TableName: aws.String(s.tableName),
                Item: map[string]types.AttributeValue{
                    "PK":        &types.AttributeValueMemberS{Value: "PRODUCT#" + productID},
                    "SK":        &types.AttributeValueMemberS{Value: "PRICE#" + now.Format(time.RFC3339Nano)},
                    "EntityType": &types.AttributeValueMemberS{Value: "PRICE_HISTORY"},
                    "ProductId": &types.AttributeValueMemberS{Value: productID},
                    "Price":     &types.AttributeValueMemberN{Value: fmt.Sprintf("%d", newPrice)},
                    "ChangedBy": &types.AttributeValueMemberS{Value: changedBy},
                    "CreatedAt": &types.AttributeValueMemberS{Value: now.Format(time.RFC3339)},
                },
            },
        },
    }

    _, err := s.client.TransactWriteItems(ctx, &dynamodb.TransactWriteItemsInput{
        TransactItems: transactItems,
    })
    return err
}
```

### 価格履歴の取得

```go
func (r *PriceHistoryRepository) GetByDateRange(
    ctx context.Context,
    productID string,
    from, to time.Time,
) ([]PriceHistory, error) {
    result, err := r.client.Query(ctx, &dynamodb.QueryInput{
        TableName:              aws.String(r.tableName),
        KeyConditionExpression: aws.String("PK = :pk AND SK BETWEEN :from AND :to"),
        ExpressionAttributeValues: map[string]types.AttributeValue{
            ":pk":   &types.AttributeValueMemberS{Value: "PRODUCT#" + productID},
            ":from": &types.AttributeValueMemberS{Value: "PRICE#" + from.Format(time.RFC3339)},
            ":to":   &types.AttributeValueMemberS{Value: "PRICE#" + to.Format(time.RFC3339) + "Z"}, // 終端を含めるため
        },
        ScanIndexForward: aws.Bool(true), // 昇順（古い順）
    })
    if err != nil {
        return nil, err
    }

    var history []PriceHistory
    for _, item := range result.Items {
        var h PriceHistory
        attributevalue.UnmarshalMap(item, &h)
        history = append(history, h)
    }
    return history, nil
}
```

---

## 在庫変動ログの実装例

### データ構造

```go
type InventoryLog struct {
    PK            string    // PRODUCT#<productId>
    SK            string    // INVLOG#<timestamp>
    ProductID     string
    ChangeType    string    // IN, OUT, ADJUST
    Quantity      int       // 変動量（正負）
    PreviousStock int
    NewStock      int
    Reason        string    // 入荷、注文、棚卸調整など
    OrderID       string    // 注文の場合
    CreatedAt     time.Time
}
```

### 在庫変動時にログ記録

```go
func (s *InventoryService) AdjustStock(
    ctx context.Context,
    productID string,
    quantity int,
    changeType string,
    reason string,
) error {
    // 1. 現在の在庫を取得
    product, err := s.productRepo.GetByID(ctx, productID)
    if err != nil {
        return err
    }

    newStock := product.Stock + quantity
    if newStock < 0 {
        return ErrInsufficientStock
    }

    now := time.Now()

    // 2. トランザクションで在庫更新とログ記録
    transactItems := []types.TransactWriteItem{
        // 在庫更新
        {
            Update: &types.Update{
                TableName: aws.String(s.tableName),
                Key: map[string]types.AttributeValue{
                    "PK": &types.AttributeValueMemberS{Value: "PRODUCT#" + productID},
                    "SK": &types.AttributeValueMemberS{Value: "METADATA"},
                },
                UpdateExpression:    aws.String("SET Stock = :newStock"),
                ConditionExpression: aws.String("Stock = :prevStock"), // 楽観的ロック
                ExpressionAttributeValues: map[string]types.AttributeValue{
                    ":newStock":  &types.AttributeValueMemberN{Value: fmt.Sprintf("%d", newStock)},
                    ":prevStock": &types.AttributeValueMemberN{Value: fmt.Sprintf("%d", product.Stock)},
                },
            },
        },
        // 在庫ログ
        {
            Put: &types.Put{
                TableName: aws.String(s.tableName),
                Item: map[string]types.AttributeValue{
                    "PK":            &types.AttributeValueMemberS{Value: "PRODUCT#" + productID},
                    "SK":            &types.AttributeValueMemberS{Value: "INVLOG#" + now.Format(time.RFC3339Nano)},
                    "EntityType":    &types.AttributeValueMemberS{Value: "INVENTORY_LOG"},
                    "ChangeType":    &types.AttributeValueMemberS{Value: changeType},
                    "Quantity":      &types.AttributeValueMemberN{Value: fmt.Sprintf("%d", quantity)},
                    "PreviousStock": &types.AttributeValueMemberN{Value: fmt.Sprintf("%d", product.Stock)},
                    "NewStock":      &types.AttributeValueMemberN{Value: fmt.Sprintf("%d", newStock)},
                    "Reason":        &types.AttributeValueMemberS{Value: reason},
                    "CreatedAt":     &types.AttributeValueMemberS{Value: now.Format(time.RFC3339)},
                },
            },
        },
    }

    _, err = s.client.TransactWriteItems(ctx, &dynamodb.TransactWriteItemsInput{
        TransactItems: transactItems,
    })
    return err
}
```

---

## ホットパーティション対策

### 問題

特定のPKにデータが集中すると、そのパーティションがボトルネックになる。

```
例: 人気商品のアクセスログ
PRODUCT#popular-item に大量のログが集中
→ スロットリング発生
```

### 対策1: 時間ベースのパーティション分割

```
# Before
PK: PRODUCT#p001
SK: ACTIVITY#2024-01-15T10:00:00Z

# After（日付をPKに含める）
PK: PRODUCT#p001#2024-01-15
SK: ACTIVITY#10:00:00Z
```

### 対策2: ランダムサフィックス

```
PK: PRODUCT#p001#0  # 0-9のランダムサフィックス
PK: PRODUCT#p001#1
...
PK: PRODUCT#p001#9
```

> 読み取り時は全サフィックスをParallel Scanする必要がある

---

## ページネーション

大量の時系列データを分割取得。

```go
func (r *PriceHistoryRepository) GetPaginated(
    ctx context.Context,
    productID string,
    limit int32,
    lastKey map[string]types.AttributeValue,
) ([]PriceHistory, map[string]types.AttributeValue, error) {
    input := &dynamodb.QueryInput{
        TableName:              aws.String(r.tableName),
        KeyConditionExpression: aws.String("PK = :pk AND begins_with(SK, :prefix)"),
        ExpressionAttributeValues: map[string]types.AttributeValue{
            ":pk":     &types.AttributeValueMemberS{Value: "PRODUCT#" + productID},
            ":prefix": &types.AttributeValueMemberS{Value: "PRICE#"},
        },
        Limit:            aws.Int32(limit),
        ScanIndexForward: aws.Bool(false), // 降順（新しい順）
    }

    if lastKey != nil {
        input.ExclusiveStartKey = lastKey
    }

    result, err := r.client.Query(ctx, input)
    if err != nil {
        return nil, nil, err
    }

    var history []PriceHistory
    for _, item := range result.Items {
        var h PriceHistory
        attributevalue.UnmarshalMap(item, &h)
        history = append(history, h)
    }

    return history, result.LastEvaluatedKey, nil
}
```

---

## 学習メモ

```
ここに学習中のメモを追記
```
